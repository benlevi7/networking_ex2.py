# Itay Etelis 209041474
# Ben Levi 318811304

import socket
import sys
import os
import time

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import utils

# initialize variables to hold arguments.
IP = sys.argv[1]
PORT = int(sys.argv[2])
PATH = str(sys.argv[3])
TIME = float(sys.argv[4])
SEP = os.path.sep


# -----------------------------------------------------------
# Class Client - in-charge to hold all data related to current client.
# -----------------------------------------------------------
class Client:
    # Constructor.
    def __init__(self):
        # initialize new socket.
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # new socket file - to avoid errors when sending UTF-8 format.
        self.client_file = self.s.makefile('rb')
        self.id = '0'
        # session_id will be generated by the server to identify different clients with same ID.
        self.session_id = '0'
        # keep time interval to schedule an update.
        self.last_update = time.time()
        # ignore paths came from updates - for future watchdog use.
        self.ignore_list = list()

    def initialize_connection(self):
        # check if argument 5 exists meaning client entered with existing ID.
        try:
            self.id = str(sys.argv[5])
            # make new connection to server.
            self.socket_rst()
            # notify the server that is a pull request.
            utils.send_string(self.s, 'SYN_DATA')
            # receive session_id from server.
            self.session_id = self.client_file.readline().strip().decode()
            # pull all data from existing client's data.
            utils.pull_data(self.s, self.client_file, PATH)

        # if no ID exists:
        except:
            # make new connection to server.
            self.socket_rst()
            # receive client's id from server.
            self.id = self.client_file.readline().strip().decode()
            # receive new session_id from server.
            self.session_id = self.client_file.readline().strip().decode()
            # push all data from existing folder.
            utils.push_data(self.s, self.client_file, PATH)
        # close connection with server.
        self.socket_close()
        # update string time to be current time.
        self.last_update = time.time()

    # socket_close method will be in-charge of closing socket and file.
    def socket_close(self):
        self.s.close()
        self.client_file.close()

    # socket_rst - method will be in-charge of initialize new socket.
    def socket_rst(self):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((IP, PORT))
        self.client_file = self.s.makefile('rb')
        # after initializing connection, send server client's id + session id.
        utils.send_string(self.s, self.id)
        utils.send_string(self.s, self.session_id)

    # update_request - method will be in-charge of notifying a server an update is needed with current client.
    def update_request(self):
        self.ignore_list.clear()
        # send update request to server.
        utils.send_string(self.s, 'UPDATE_TIME')
        # number of updates server has for current client.
        num_updates = int((self.client_file.readline().decode().strip()))
        # implement each update came from server by order given.
        for update in range(num_updates):
            # receive task identifier from server.
            comment = self.client_file.readline().decode().strip()
            # if server is about to send a new file, go to pull new file.
            if comment == 'NEW_FILE':
                relative_path = utils.pull_new_file(self.s, self.client_file, PATH)
                # add path to ignore list - for watchdog to ignore.
                self.ignore_list.append(utils.join_paths(relative_path, PATH))
            # otherwise if server is about to send new dir name, create a new dir.
            elif comment == 'NEW_DIR':
                relative_path = self.client_file.readline().strip().decode()
                os.makedirs(utils.join_paths(relative_path, PATH), exist_ok=True)
                # add path to ignore list - for watchdog to ignore.
                self.ignore_list.extend([utils.join_paths(relative_path, PATH)] * 2)
            # otherwise if server requesting deletion of a file or folder, execute task.
            elif comment == 'DELETE':
                relative_path = utils.pull_delete_file(self.client_file, PATH)
                # add path to ignore list - for watchdog to ignore.
                self.ignore_list.extend([utils.join_paths(relative_path, PATH)] * 3)

        # update last update time to current time.
        self.last_update = time.time()

# -----------------------------------------------------------
# Watcher Class - class will be in-charged of running main loop and operating WatchDog module.
# -----------------------------------------------------------
class Watcher:
    # Constructor.
    def __init__(self, client):
        self.my_observer = Observer()
        self.client = client

    # run method - will be in-charged of running main loop for client, on update will connect to server.
    def run(self):
        my_event_handler = Handler(self.client)
        self.my_observer.schedule(my_event_handler, PATH, recursive=True)
        self.my_observer.start()
        try:
            while True:
                # if update time interval arrived, connect to server and update.
                if self.client.last_update + TIME < time.time():
                    # make new socket connection to server.
                    self.client.socket_rst()
                    # receive the updates.
                    self.client.update_request()
                    # close connection with server.
                    self.client.socket_close()
                time.sleep(5)
        except KeyboardInterrupt:
            self.my_observer.stop()
        self.my_observer.join()


# -----------------------------------------------------------
# Handler Class - Will be in-charged of events coming from Watchdog module.
# -----------------------------------------------------------
class Handler(FileSystemEventHandler):
    def __init__(self, client):
        self.client = client

    # send_created_file method - if watchdog detected new file created in the folder, notify the server by request.
    def send_created_file(self, src_path):
        relative_path = str(src_path)[len(PATH):]
        # of path is actually a dir and not a file.
        if os.path.isdir(src_path):
            utils.send_string(self.client.s, 'NEW_DIR')
            utils.send_string(self.client.s, relative_path)
        # otherwise path is a file and needed to be sent accordingly.
        else:
            utils.send_string(self.client.s, 'NEW_FILE')
            utils.push_file(self.client.s, self.client.client_file, src_path, PATH)

    # send_delete_file - if watchdog detected file or folder being delete, notify the server by request.
    def send_delete_file(self, src_path):
        relative_path = str(src_path)[len(PATH):]
        utils.send_string(self.client.s, 'DELETE')
        utils.send_string(self.client.s, relative_path)

    # send_modify_file - if watchdog detected file or folder being modified, notify the server by delete and creation.
    def send_modify_file(self, src_path, dest_path):
        utils.send_string(self.client.s, 'CHANGE')
        self.send_delete_file(src_path)
        self.send_created_file(dest_path)

    # on_any_event - method for the watchdog module, on any event watchdog thread will arrive here working accordingly.
    def on_any_event(self, event):
        # sleep to make sure updates took place.
        time.sleep(0.5)

        # if current event caused by an update from the sever ignore it.
        if any(str(event.src_path).startswith(s) for s in self.client.ignore_list):
            if event.src_path in self.client.ignore_list:
                self.client.ignore_list.remove(event.src_path)
            return

        # if event is temporary created file by system ignore.
        if ((str(event.src_path).split(SEP))[-1])[0] == '.':
            if event.event_type != 'moved':
                return

        # otherwise initialize new connection with server.
        self.client.socket_rst()

        # on created:
        if event.event_type == 'created':
            self.send_created_file(event.src_path)

        # on deleted:
        elif event.event_type == 'deleted':
            self.send_delete_file(event.src_path)

        # on modified:
        elif event.event_type == 'moved':
            if ((str(event.src_path).split(SEP))[-1])[0] == '.':
                self.send_modify_file(event.dest_path, event.dest_path)
            else:
                self.send_modify_file(event.src_path, event.dest_path)

        # close connection with server.
        self.client.socket_close()


c = Client()
c.initialize_connection()
w = Watcher(c)
w.run()
